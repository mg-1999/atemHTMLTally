/* -LICENSE-START-
** Copyright (c) 2011 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
** 
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#import "SwitcherPanelAppDelegate.h"
#import "HTTPServer.h"
#import "DDLog.h"
#import "DDTTYLogger.h"

#include <libkern/OSAtomic.h>
#include <string>
static const int ddLogLevel = LOG_LEVEL_OFF;

static inline bool	operator== (const REFIID& iid1, const REFIID& iid2)
{ 
	return CFEqual(&iid1, &iid2);
}

// Callback class for monitoring property changes on a mix effect block.
class MixEffectBlockMonitor : public IBMDSwitcherMixEffectBlockCallback
{
public:
	MixEffectBlockMonitor(SwitcherPanelAppDelegate* uiDelegate) : mUiDelegate(uiDelegate), mRefCount(1) { }

protected:
	virtual ~MixEffectBlockMonitor() { }

public:
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, LPVOID *ppv)
	{
		if (!ppv)
			return E_POINTER;
		
		if (iid == IID_IBMDSwitcherMixEffectBlockCallback)
		{
			*ppv = static_cast<IBMDSwitcherMixEffectBlockCallback*>(this);
			AddRef();
			return S_OK;
		}
		
		if (CFEqual(&iid, IUnknownUUID))
		{
			*ppv = static_cast<IUnknown*>(this);
			AddRef();
			return S_OK;
		}
		
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	ULONG STDMETHODCALLTYPE AddRef(void)
	{
		return ::OSAtomicIncrement32(&mRefCount);
	}

	ULONG STDMETHODCALLTYPE Release(void)
	{
		int newCount = ::OSAtomicDecrement32(&mRefCount);
		if (newCount == 0)
			delete this;
		return newCount;
	}
	
	HRESULT PropertyChanged(BMDSwitcherMixEffectBlockPropertyId propertyId)
	{
		switch (propertyId)
		{
			case bmdSwitcherMixEffectBlockPropertyIdProgramInput:
				[mUiDelegate performSelectorOnMainThread:@selector(updateProgramButtonSelection) withObject:nil waitUntilDone:YES];
				[mUiDelegate performSelectorOnMainThread:@selector(wUpdateTallyProgram) withObject:nil waitUntilDone:YES];
				break;
			case bmdSwitcherMixEffectBlockPropertyIdPreviewInput:
				[mUiDelegate performSelectorOnMainThread:@selector(updatePreviewButtonSelection) withObject:nil waitUntilDone:YES];
                [mUiDelegate performSelectorOnMainThread:@selector(wUpdateTallyPreview) withObject:nil waitUntilDone:YES];
				break;
			case bmdSwitcherMixEffectBlockPropertyIdInTransition:
				[mUiDelegate performSelectorOnMainThread:@selector(updateInTransitionState) withObject:nil waitUntilDone:YES];
				break;
			case bmdSwitcherMixEffectBlockPropertyIdTransitionPosition:
				[mUiDelegate performSelectorOnMainThread:@selector(updateSliderPosition) withObject:nil waitUntilDone:YES];
				[mUiDelegate performSelectorOnMainThread:@selector(writeToServer) withObject:nil waitUntilDone:YES];
				break;
			case bmdSwitcherMixEffectBlockPropertyIdTransitionFramesRemaining:
				[mUiDelegate performSelectorOnMainThread:@selector(updateTransitionFramesTextField) withObject:nil waitUntilDone:YES];
				break;
			case bmdSwitcherMixEffectBlockPropertyIdFadeToBlackFramesRemaining:
				[mUiDelegate performSelectorOnMainThread:@selector(updateFTBFramesTextField) withObject:nil waitUntilDone:YES];
				break;
			default:	// ignore other property changes not used for this sample app
				break;
		}
		return S_OK;
	}

private:
	SwitcherPanelAppDelegate*		mUiDelegate;
	int								mRefCount;
};

// Monitor the properties on Switcher Inputs.
// In this sample app we're only interested in changes to the Long Name property to update the PopupButton list
class InputMonitor : public IBMDSwitcherInputCallback
{
public:
	InputMonitor(IBMDSwitcherInput* input, SwitcherPanelAppDelegate* uiDelegate) : mInput(input), mUiDelegate(uiDelegate), mRefCount(1)
	{
		mInput->AddRef();
		mInput->AddCallback(this);
	}

protected:
	~InputMonitor()
	{
		mInput->RemoveCallback(this);
		mInput->Release();
	}
	
public:
	// IBMDSwitcherInputCallback interface
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, LPVOID *ppv)
	{
		if (!ppv)
			return E_POINTER;
		
		if (iid == IID_IBMDSwitcherInputCallback)
		{
			*ppv = static_cast<IBMDSwitcherInputCallback*>(this);
			AddRef();
			return S_OK;
		}
		
		if (CFEqual(&iid, IUnknownUUID))
		{
			*ppv = static_cast<IUnknown*>(this);
			AddRef();
			return S_OK;
		}
		
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	ULONG STDMETHODCALLTYPE AddRef(void)
	{
		return ::OSAtomicIncrement32(&mRefCount);
	}

	ULONG STDMETHODCALLTYPE Release(void)
	{
		int newCount = ::OSAtomicDecrement32(&mRefCount);
		if (newCount == 0)
			delete this;
		return newCount;
	}

	HRESULT PropertyChanged(BMDSwitcherInputPropertyId propertyId)
	{
		switch (propertyId)
		{
			case bmdSwitcherInputPropertyIdLongName:
				[mUiDelegate performSelectorOnMainThread:@selector(updatePopupButtonItems) withObject:nil waitUntilDone:YES];
			default:	// ignore other property changes not used for this sample app
				break;
		}
		
		return S_OK;
	}
	IBMDSwitcherInput* input() { return mInput; }
	
private:
	IBMDSwitcherInput*			mInput;
	SwitcherPanelAppDelegate*	mUiDelegate;
	int							mRefCount;
};

// Callback class to monitor switcher disconnection
class SwitcherMonitor : public IBMDSwitcherCallback
{
public:
	SwitcherMonitor(SwitcherPanelAppDelegate* uiDelegate) :	mUiDelegate(uiDelegate), mRefCount(1) { }

protected:
	virtual ~SwitcherMonitor() { }
	
public:
	// IBMDSwitcherCallback interface
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, LPVOID *ppv)
	{
		if (!ppv)
			return E_POINTER;
		
		if (iid == IID_IBMDSwitcherCallback)
		{
			*ppv = static_cast<IBMDSwitcherCallback*>(this);
			AddRef();
			return S_OK;
		}
		
		if (CFEqual(&iid, IUnknownUUID))
		{
			*ppv = static_cast<IUnknown*>(this);
			AddRef();
			return S_OK;
		}
		
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	ULONG STDMETHODCALLTYPE AddRef(void)
	{
		return ::OSAtomicIncrement32(&mRefCount);
	}

	ULONG STDMETHODCALLTYPE Release(void)
	{
		int newCount = ::OSAtomicDecrement32(&mRefCount);
		if (newCount == 0)
			delete this;
		return newCount;
	}
	
	// Switcher events ignored by this sample app
	HRESULT STDMETHODCALLTYPE	Notify(BMDSwitcherEventType eventType) {
        switch(eventType) {
            case bmdSwitcherEventTypeDisconnected:
                [mUiDelegate performSelectorInBackground:@selector(switcherDisconnected) withObject:nil];
            break;
                
        }
        return S_OK; }
	
	HRESULT STDMETHODCALLTYPE	Disconnected(void)
	{
		[mUiDelegate performSelectorOnMainThread:@selector(switcherDisconnected) withObject:nil waitUntilDone:YES];
		return S_OK;
	}
	
private:
	SwitcherPanelAppDelegate*	mUiDelegate;
	int							mRefCount;
};


@implementation SwitcherPanelAppDelegate

@synthesize window;

- (void)applicationDidFinishLaunching:(NSNotification *)aNotification
{
	mSwitcherDiscovery = NULL;
	mSwitcher = NULL;
	mMixEffectBlock = NULL;
	
	mSwitcherMonitor = new SwitcherMonitor(self);
	mMixEffectBlockMonitor = new MixEffectBlockMonitor(self);
	
	mMoveSliderDownwards = false;
	mCurrentTransitionReachedHalfway = false;
	
	mSwitcherDiscovery = CreateBMDSwitcherDiscoveryInstance();
	if (! mSwitcherDiscovery)
	{
		NSBeginAlertSheet(@"Could not create Switcher Discovery Instance.\nATEM Switcher Software may not be installed.\n",
							@"OK", nil, nil, window, self, @selector(sheetDidEndShouldTerminate:returnCode:contextInfo:), NULL, window, @"");
	}
    
    [wServerPath retain];
    
    //w Init
    if ([[[[NSUserDefaults standardUserDefaults] dictionaryRepresentation] allKeys] containsObject:@"magic"]) {
        wHTTPServerPortField.stringValue = [[NSUserDefaults standardUserDefaults] valueForKey:@"wHTTPServerPort"];
        wServerPath = [[NSUserDefaults standardUserDefaults] valueForKeyPath:@"wServerPath"];
        mAddressTextField.stringValue = [[NSUserDefaults standardUserDefaults] valueForKey:@"mAddressText"];
        NSMutableArray* tmpArray = [[NSUserDefaults standardUserDefaults] objectForKey:@"tally"];
        
        for (int i = 0; i < 11000; i++) {
            tally[i] = [[tmpArray objectAtIndex:i] intValue];
        }
    
    } else {
    
        for (int i=0;i< 11000;i++) {
                tally[i]=0;
        }
        tally[1] = 5;
        tally[2] = 6;
        tally[3] = 1;
        tally[4] = 2;
        tally[5] = 3;
        tally[6] = 4;
        [wHTTPServerPortField setStringValue:@"8080"];
    }
    lastPreviewId = 0;
    lastProgramId = 0;
    [wInputPopup removeAllItems];
    wHTTPServerHandle = [[HTTPServer alloc] init];
    if (wServerPath == nil) {
        NSString *currentPath = [[NSBundle mainBundle] bundlePath];
        wServerPath = currentPath;
        wServerPath = [[[wServerPath stringByAppendingString:@"/../tally"] stringByExpandingTildeInPath] stringByStandardizingPath];
    }
    [wServerPathText setStringValue:wServerPath];
	[self switcherDisconnected];		// start with switcher disconnected
}

- (void)applicationWillTerminate:(NSNotification*)aNotification
{
    //Save state
    NSMutableArray* tmpArray  = [[NSMutableArray alloc] init];
    for (int i = 0; i < 11000; i++) {
        [tmpArray addObject:[NSNumber numberWithInt:tally[i]]];
    }
    
    //Ref:http://stackoverflow.com/questions/11055828/xcode-4-3-saving-user-data
    [[NSUserDefaults standardUserDefaults] setInteger:3333 forKey:@"magic"];
    [[NSUserDefaults standardUserDefaults] setValue:[wServerPathText stringValue] forKey:@"wServerPath"];
    [[NSUserDefaults standardUserDefaults] setValue:wHTTPServerPortField.stringValue forKey:@"wHTTPServerPort"];
    [[NSUserDefaults standardUserDefaults] setValue:mAddressTextField.stringValue forKey:@"mAddressText"];
  
    [[NSUserDefaults standardUserDefaults] setObject:tmpArray forKey:@"tally"];
    [[NSUserDefaults standardUserDefaults] synchronize];
    
    [tmpArray release];
    [wServerPath release];
    
	mSwitcherMonitor->Release();
	mSwitcherMonitor = NULL;
	
	mMixEffectBlockMonitor->Release();
	mMixEffectBlockMonitor = NULL;

	if (mSwitcherDiscovery)
	{
		mSwitcherDiscovery->Release();
		mSwitcherDiscovery = NULL;
	}
}

- (BOOL)applicationShouldTerminateAfterLastWindowClosed:(NSApplication*)sender
{
    
    
	return YES;
}

- (void)sheetDidEndShouldTerminate:(NSWindow *)sheet returnCode:(NSInteger)returnCode contextInfo:(void *)contextInfo
{
	[NSApp terminate:self];
}

//
// Actions
//

- (void)connectBMD; {
	NSString* address = [mAddressTextField stringValue];
	
	BMDSwitcherConnectToFailure			failReason;
	
	// Note that ConnectTo() can take several seconds to return, both for success or failure,
	// depending upon hostname resolution and network response times, so it may be best to
	// do this in a separate thread to prevent the main GUI thread blocking.
	HRESULT hr = mSwitcherDiscovery->ConnectTo((CFStringRef)address, &mSwitcher, &failReason);
	if (SUCCEEDED(hr))
	{
        [self changeConnectionStatus:1];
		[self switcherConnected];
	}
	else
	{
		NSString* reason;
		switch (failReason)
		{
			case bmdSwitcherConnectToFailureNoResponse:
				reason = @"No response from Switcher";
				break;
			case bmdSwitcherConnectToFailureIncompatibleFirmware:
				reason = @"Switcher has incompatible firmware";
				break;
			default:
				reason = @"Connection failed for unknown reason";
		}
        double delayInSeconds = 2.0;
        dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC);
        dispatch_after(popTime, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0),
                       ^(void){
                           [self switcherDisconnected];
                       });
		NSLog(reason);
	}
}

- (IBAction)cutButtonPressed:(id)sender
{
	mMixEffectBlock->PerformCut();
}

- (IBAction)autoButtonPressed:(id)sender
{
	mMixEffectBlock->PerformAutoTransition();
}

- (IBAction)FTBButtonPressed:(id)sender
{
	mMixEffectBlock->PerformFadeToBlack();
}

- (IBAction)programPopupChanged:(id)sender
{
	BMDSwitcherInputId selectedProgramInput = [[mProgramInputsPopup selectedItem] tag];
	mMixEffectBlock->SetInt(bmdSwitcherMixEffectBlockPropertyIdProgramInput, selectedProgramInput);
}

- (IBAction)previewPopupChanged:(id)sender
{
	BMDSwitcherInputId selectedPreviewInput = [[mPreviewInputsPopup selectedItem] tag];
	mMixEffectBlock->SetInt(bmdSwitcherMixEffectBlockPropertyIdPreviewInput, selectedPreviewInput);
}

- (IBAction)sliderChanged:(id)sender
{
	double position = [mSlider doubleValue] / 100.0;
	if (mMoveSliderDownwards)
		position = (100 - [mSlider doubleValue]) / 100.0;		// deal with flipped slider handle position

	mMixEffectBlock->SetFloat(bmdSwitcherMixEffectBlockPropertyIdTransitionPosition, position);
}

- (void)switcherConnected
{
	HRESULT result;
	IBMDSwitcherMixEffectBlockIterator* iterator = NULL;
	IBMDSwitcherInputIterator* inputIterator = NULL;
	
	[mConnectButton setEnabled:NO];			// disable Connect button while connected
	
	NSString* productName;
	if (FAILED(mSwitcher->GetProductName((CFStringRef*)&productName)))
	{
		NSLog(@"Could not get switcher product name");
		return;
	}
	
	[mSwitcherNameLabel setStringValue:productName];
	[productName release];
	
	mSwitcher->AddCallback(mSwitcherMonitor);
	
	// Create an InputMonitor for each input so we can catch any changes to input names
	result = mSwitcher->CreateIterator(IID_IBMDSwitcherInputIterator, (void**)&inputIterator);
	if (SUCCEEDED(result))
	{
		IBMDSwitcherInput* input = NULL;
		
		// For every input, install a callback to monitor property changes on the input
		while (S_OK == inputIterator->Next(&input))
		{
			InputMonitor* inputMonitor = new InputMonitor(input, self);
			input->Release();
			mInputMonitors.push_back(inputMonitor);
		}
		inputIterator->Release();
		inputIterator = NULL;
	}
		
	// Get the mix effect block iterator
	result = mSwitcher->CreateIterator(IID_IBMDSwitcherMixEffectBlockIterator, (void**)&iterator);
	if (FAILED(result))
	{
		NSLog(@"Could not create IBMDSwitcherMixEffectBlockIterator iterator");
		goto finish;
	}
	
	// Use the first Mix Effect Block
	if (S_OK != iterator->Next(&mMixEffectBlock))
	{
		NSLog(@"Could not get the first IBMDSwitcherMixEffectBlock");
		goto finish;
	}
	
	mMixEffectBlock->AddCallback(mMixEffectBlockMonitor);
	
	[self mixEffectBlockBoxSetEnabled:YES];
	[self updatePopupButtonItems];
	[self updateSliderPosition];
	[self updateTransitionFramesTextField];
	[self updateFTBFramesTextField];
    [self wUpdateTallyProgram];
    [self wUpdateTallyPreview];
	
finish:
	if (iterator)
		iterator->Release();
}

- (void)switcherDisconnected
{
    // enable connect button so user can re-connect
    [self changeConnectionStatus:0];
    
	[mSwitcherNameLabel setStringValue:@""];
	
	[self mixEffectBlockBoxSetEnabled:NO];
	
	// cleanup resources created when switcher was connected
	for (std::list<InputMonitor*>::iterator it = mInputMonitors.begin(); it != mInputMonitors.end(); ++it)
	{
		(*it)->Release();
	}
	mInputMonitors.clear();
	
	if (mMixEffectBlock)
	{
		mMixEffectBlock->RemoveCallback(mMixEffectBlockMonitor);
		mMixEffectBlock->Release();
		mMixEffectBlock = NULL;
	}
	
	if (mSwitcher)
	{
		mSwitcher->RemoveCallback(mSwitcherMonitor);
		mSwitcher->Release();
		mSwitcher = NULL;
	}
    [self connectBMD];
    
}

//
// GUI updates
//
- (void)updatePopupButtonItems
{
	HRESULT result;
	IBMDSwitcherInputIterator* inputIterator = NULL;
	IBMDSwitcherInput* input = NULL;
	
	result = mSwitcher->CreateIterator(IID_IBMDSwitcherInputIterator, (void**)&inputIterator);
	if (FAILED(result))
	{
		NSLog(@"Could not create IBMDSwitcherInputIterator iterator");
		return;
	}
	
	[mProgramInputsPopup removeAllItems];
	[mPreviewInputsPopup removeAllItems];

	while (S_OK == inputIterator->Next(&input))
	{
		NSString* name;
		BMDSwitcherInputId id;

		input->GetInputId(&id);
		input->GetString(bmdSwitcherInputPropertyIdLongName, (CFStringRef*)&name);
		[wInputPopup addItemWithTitle:name];
        [[wInputPopup lastItem] setTag:id];
        
        
		[mProgramInputsPopup addItemWithTitle:name];
		[[mProgramInputsPopup lastItem] setTag:id];
		
		[mPreviewInputsPopup addItemWithTitle:name];
		[[mPreviewInputsPopup lastItem] setTag:id];
		
		input->Release();
		[name release];
	}
	inputIterator->Release();
	
	[self updateProgramButtonSelection];
	[self updatePreviewButtonSelection];
}

- (void)updateProgramButtonSelection
{
	BMDSwitcherInputId	programId;
	mMixEffectBlock->GetInt(bmdSwitcherMixEffectBlockPropertyIdProgramInput, &programId);
	[mProgramInputsPopup selectItemWithTag:programId];
}

- (void)updatePreviewButtonSelection
{
	BMDSwitcherInputId	previewId;
	mMixEffectBlock->GetInt(bmdSwitcherMixEffectBlockPropertyIdPreviewInput, &previewId);
	[mPreviewInputsPopup selectItemWithTag:previewId];
}

- (void)updateInTransitionState
{
	bool inTransition;
	mMixEffectBlock->GetFlag(bmdSwitcherMixEffectBlockPropertyIdInTransition, &inTransition);
	
	if (inTransition == false)
	{
		// Toggle the starting orientation of slider handle if a transition has passed through halfway
		if (mCurrentTransitionReachedHalfway)
		{
			mMoveSliderDownwards = ! mMoveSliderDownwards;
			[self updateSliderPosition];
		}
		
		mCurrentTransitionReachedHalfway = false;
	}
}

- (void)updateSliderPosition
{
	double position;
	mMixEffectBlock->GetFloat(bmdSwitcherMixEffectBlockPropertyIdTransitionPosition, &position);
	
	// Record when transition passes halfway so we can flip orientation of slider handle at the end of transition
	mCurrentTransitionReachedHalfway = (position >= 0.50);

	double sliderPosition = position * 100;
	if (mMoveSliderDownwards)
		sliderPosition = 100 - position * 100;		// slider handle moving in opposite direction
	
	[mSlider setDoubleValue:sliderPosition];
	[mLevelIndicator setDoubleValue:position * 20];
}

- (void)updateTransitionFramesTextField
{
	int64_t framesRemaining;
	mMixEffectBlock->GetInt(bmdSwitcherMixEffectBlockPropertyIdTransitionFramesRemaining, &framesRemaining);
	[mTransitionFramesTextField setIntegerValue:framesRemaining];
}

- (void)updateFTBFramesTextField
{
	int64_t framesRemaining;
	mMixEffectBlock->GetInt(bmdSwitcherMixEffectBlockPropertyIdFadeToBlackFramesRemaining, &framesRemaining);
	[mFTBFramesTextField setIntegerValue:framesRemaining];
}

- (void)mixEffectBlockBoxSetEnabled:(bool)enabled
{
	[mProgramInputsPopup setEnabled:enabled];
	[mPreviewInputsPopup setEnabled:enabled];
	[mCutButton setEnabled:enabled];
	[mAutoButton setEnabled:enabled];
	[mFTBButton setEnabled:enabled];
	[mSlider setEnabled:enabled];
	[mTransitionFramesTextField setEnabled:enabled];
	[mFTBFramesTextField setEnabled:enabled];
}


//************************************************************************************************************************
//************************************************************************************************************************


- (IBAction)wMappingNoChanged:(id)sender{
    int m = [wMappingNo intValue];
    int i = [[wInputPopup selectedItem] tag];
    tally[i] = m;
}

-(void)wUpdateTallyPreview {
    BMDSwitcherInputId	previewId;
	mMixEffectBlock->GetInt(bmdSwitcherMixEffectBlockPropertyIdPreviewInput, &previewId);
    
    
    
    if (lastPreviewId != 0) {
        if (previewId != lastPreviewId) {
            //Preview Changed
            NSLog([NSString stringWithFormat:@"PreviewChanged: %lld",previewId]);
            
        }
    }
    lastPreviewId = previewId;
    [self writeToServer];
    
}

-(void)wUpdateTallyProgram {
    BMDSwitcherInputId	programId;
	mMixEffectBlock->GetInt(bmdSwitcherMixEffectBlockPropertyIdProgramInput, &programId);
    
    if (lastProgramId != 0) {
        if (programId != lastProgramId) {
            //Program Changed
            NSLog([NSString stringWithFormat:@"ProgramChanged: %lld",programId]);
            
        }
    }
    lastProgramId = programId;
    [self writeToServer];

}

-(void)writeToServer {
    NSString* fileAtPath = wServerPath;
    double position;
	mMixEffectBlock->GetFloat(bmdSwitcherMixEffectBlockPropertyIdTransitionPosition, &position);
    int fading = 0;
    if ((position != 0) and (position != 1)) {
        fading = 1;
    }
    
    /*if (![[NSFileManager defaultManager] fileExistsAtPath:fileAtPath]) {*/
        [[NSFileManager defaultManager] createFileAtPath:fileAtPath contents:nil attributes:nil];
    /*}*/
    
    // The main act...
    NSString* stringToServer = [NSString stringWithFormat:@"%d%d%d",tally[lastProgramId],tally[lastPreviewId],fading];
    [[stringToServer dataUsingEncoding:NSUTF8StringEncoding] writeToFile:fileAtPath atomically:NO];

}

- (IBAction)wInputPopupChanged:(id)sender {
    [wMappingNo setIntegerValue:tally[[[wInputPopup selectedItem] tag]]];
    //NSLog([NSString stringWithFormat:@"%lld", (int64_t)[[wInputPopup selectedItem] tag]]);
}

- (IBAction)wUpdateServerPath:(id)sender {
    wServerPath = [[wServerPathText.stringValue stringByExpandingTildeInPath] stringByStandardizingPath];
    wServerPathText.stringValue = wServerPath;
}


- (void)changeConnectionStatus:(int)statusCode {
    if (statusCode == 0) {
        wConnectionStatus.textColor = [NSColor redColor];
        wConnectionStatus.backgroundColor = [NSColor blackColor];
        wConnectionStatus.stringValue = @"Disconnect";
    } else {
        wConnectionStatus.textColor = [NSColor blackColor];
        wConnectionStatus.backgroundColor = [NSColor greenColor];
        wConnectionStatus.stringValue = @"Connected";
    }
}

- (IBAction)wHTTPServerButtonClicked:(id)sender {
    //[DDLog addLogger:[DDTTYLogger sharedInstance]];
    
    if(wHTTPServerIsRunning) {
        [wHTTPServerHandle stop];
        wHTTPServerIsRunning = NO;
        wHTTPServerButton.title = @"Start HTTP Server";
        wHTTPServerStatus.textColor = [NSColor redColor];
        wHTTPServerStatus.backgroundColor = [NSColor blackColor];
        wHTTPServerStatus.stringValue = @"Stopped";
    } else {
        [wHTTPServerHandle setType:@"_http._tcp."];
        [wHTTPServerHandle setPort:[wHTTPServerPortField integerValue]];
        [wHTTPServerHandle setDocumentRoot:[wServerPath stringByDeletingLastPathComponent]];
                
        NSError *error = nil;
        if(![wHTTPServerHandle start:&error])
        {
            NSAlert *alert = [NSAlert alertWithError:error];
            [alert runModal];
            [alert release];
        } else {
            wHTTPServerIsRunning = YES;
            wHTTPServerButton.title = @"Stop HTTP Server";
            wHTTPServerStatus.textColor = [NSColor blackColor];
            wHTTPServerStatus.backgroundColor = [NSColor greenColor];
            wHTTPServerStatus.stringValue = @"Running";
    
        }
    }
}

@end
